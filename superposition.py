# -*- coding: utf-8 -*-
"""Superposition.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1j9YQIYRNkenXpPr5eLhVomrAEKdVhvN4
"""

!pip install qiskit

from qiskit import *
from qiskit.visualization import plot_histogram

from math import sqrt, pi


#Initialization states must be normalized, otherwise you may recieve error

#Let's try 1 & 0

initial_state = [1,0]
qc = QuantumCircuit(1)
qc.initialize(initial_state,0)
qc.draw()

get_states = execute(qc, Aer.get_backend('statevector_simulator')).result()
print(get_states.get_statevector())

plot_histogram(get_states.get_counts())

"""# Let's try Superposition"""

qc_1 = QuantumCircuit(1)
superposition_state = [1/sqrt(2), 1/sqrt(2)]
qc_1.initialize(superposition_state,0)
qc_1.draw()

get_superposition_states = execute(qc_1, Aer.get_backend("statevector_simulator")).result()
print(get_superposition_states.get_statevector())

plot_histogram(get_superposition_states.get_counts())

"""# Rules of Measurement (Normalization Exercise)

Create a state vector that will give a  1/3  probability of measuring  |0⟩ .
"""

state_vector = [1/sqrt(3), sqrt(2)/sqrt(3)]

ex =  QuantumCircuit(1)
ex.initialize(state_vector,0)

backend = Aer.get_backend('statevector_simulator')

plot_histogram(execute(ex,backend).result().get_counts())

"""Create a different state vector that will give the same measurement probabilities.

**In the equation above,  |x⟩  can be any qubit state. To find the probability of measuring  |x⟩ , we take the inner product of  |x⟩  and the state we are measuring (in this case  |ψ⟩ ), then square the magnitude. This may seem a little convoluted, but it will soon become second nature.**

![image.png](data:image/png;base64,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)

Probability of measuring |x> state for any other state is basically dot product of <x| (column vector) with the current state and then, squaring the magnitude

# Collapsing of Qubits post-measurement (Checking with Superposition)
"""

collapse = QuantumCircuit(1)

collapse.initialize(superposition_state,0)

collapse.measure_all()

plot_histogram(execute(collapse,backend).result().get_counts())

"""Yes. The qubit was initialised with superposition state-vectors, however post-measuring it, the state was collapsed - as no probabilities of 1 was found."""

